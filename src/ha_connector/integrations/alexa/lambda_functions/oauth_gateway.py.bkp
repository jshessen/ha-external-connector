"""
üîê CLOUDFLARE OAUTH GATEWAY: Dedicated OAuth Authentication Service üåê

=== WHAT THIS FILE DOES (OAuth Authentication Specialist) ===

This file is your dedicated "OAuth authentication specialist" that handles ONLY
OAuth token exchange for Alexa Smart Home account linking. It provides optional
CloudFlare protection for enhanced security when needed.

üîó **OAUTH ACCOUNT LINKING WORKFLOW:**

1. üì± User opens Alexa app ‚Üí Skills & Games ‚Üí [Your Smart Home Skill]
2. üîó User clicks "Enable Skill" ‚Üí "Link Account"
3. üåê Alexa redirects to YOUR Home Assistant ‚Üí `/auth/authorize`
4. üîê User enters Home Assistant credentials and authorizes
5. üîÑ Home Assistant redirects back to THIS CODE with authorization code
6. üé´ THIS CODE exchanges authorization code for access token with Home Assistant
7. üõ°Ô∏è THIS CODE adds CloudFlare headers for enhanced security (if configured)
8. ‚úÖ Alexa receives the access token and account is linked

=== ALEXA SKILL CONFIGURATION ALIGNMENT ===

This Lambda function is specifically designed to work with the Alexa skill
configuration:

üéØ **AUTH CODE GRANT FLOW (Amazon Required):**
- **Authorization Grant Type**: Auth Code Grant
- **Client ID**: https://pitangui.amazon.com/ (Amazon's identifier)
- **Access Token URI**: Points to THIS Lambda function
- **Authentication Scheme**: Credentials in request body
- **Scope**: smart_home

üîß **TOKEN EXCHANGE PROCESS:**
1. Alexa sends POST request with `application/x-www-form-urlencoded` content
2. THIS CODE validates the request using shared security infrastructure
3. THIS CODE forwards the token exchange to Home Assistant `/auth/token`
4. THIS CODE adds CloudFlare Access headers if configured for extra security
5. THIS CODE returns the OAuth response back to Alexa

=== CLOUDFLARE INTEGRATION (OPTIONAL) ===

üõ°Ô∏è **ENHANCED SECURITY MODE (CloudFlare Access):**
When CloudFlare Access is configured, this Lambda adds security headers:
- `CF-Access-Client-Id`: Your CloudFlare Access application ID
- `CF-Access-Client-Secret`: Your CloudFlare Access application secret

This provides an additional security layer protecting your Home Assistant instance
from unauthorized access attempts.

ÔøΩ **CONFIGURATION OPTIONS:**
- **Direct Mode**: Direct OAuth communication with Home Assistant (standard)
- **Protected Mode**: OAuth + CloudFlare Access headers (enhanced security)

=== SPECIALIZED ARCHITECTURE ===

üè¢ **OAUTH SPECIALIST IN TWO-LAMBDA ARCHITECTURE**

This OAuth Gateway works alongside `smart_home_bridge.py` in a specialized division:

ÔøΩ **OAUTH GATEWAY (THIS FILE - oauth_gateway.py)**
- ÔøΩ **Specialization**: OAuth authentication and account linking ONLY
- üõ°Ô∏è **Security Level**: HIGH (account linking requires maximum security)
- ÔøΩ **CloudFlare Support**: YES (optional enhanced protection)
- üìã **Responsibilities**:
  * Handle OAuth authorization code exchange
  * Add CloudFlare Access headers when configured
  * Cache OAuth tokens for performance
  * Validate OAuth requests using shared security framework
  * Process ONLY OAuth authentication flows

‚ö° **SMART HOME BRIDGE (smart_home_bridge.py)**
- ÔøΩ **Specialization**: Voice command processing ONLY
- üõ°Ô∏è **Security Level**: OPTIMIZED (sub-500ms response priority)
- üåê **CloudFlare Support**: NO (direct communication for performance)
- üìã **Responsibilities**:
  * Process voice commands with maximum speed
  * Use existing OAuth tokens (no account linking)
  * Direct Home Assistant communication (no CloudFlare overhead)

=== CLOUDFLARE ACCESS CONFIGURATION ===

To enable CloudFlare protection, configure these environment variables:
- `CF_CLIENT_ID`: Your CloudFlare Access application client ID
- `CF_CLIENT_SECRET`: Your CloudFlare Access application secret

Without these, the Lambda operates in direct mode (standard OAuth).

=== TECHNICAL IMPLEMENTATION ===

üöÄ **PERFORMANCE FEATURES:**
- Dual-layer OAuth token caching (container + DynamoDB)
- Shared security infrastructure integration
- Optimized for OAuth-specific workflows
- CloudFlare header injection when configured

üõ°Ô∏è **SECURITY FEATURES:**
- Rate limiting protection using shared RateLimiter
- Request validation using shared SecurityValidator
- Security event logging for OAuth operations
- Bearer token handling and validation

Author: Jeff Hessenflow <jeff.hessenflow@gmail.com>
Based on original work by: Jason Hu <awaregit@gmail.com>
Copyright 2019 Jason Hu <awaregit at gmail.com>
Licensed under the Apache License, Version 2.0
"""

# pylint: disable=too-many-lines  # Lambda functions must be standalone
# pylint: disable=duplicate-code  # Lambda functions must be standalone - no shared modules

# ‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ IMPORT_BLOCK_START ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ
import base64
import configparser
import logging
import os
import time
import urllib.parse
from dataclasses import dataclass
from decimal import Decimal
from typing import Any, cast

import boto3
from botocore.exceptions import BotoCoreError, ClientError

from .shared_configuration import (
    OAUTH_TOKEN_CACHE_TABLE,
    RateLimiter,
    SecurityEventLogger,
    SecurityValidator,
    cache_config_in_container,
    create_error_response,
    create_lambda_logger,
    extract_correlation_id,
    get_container_cached_config,
    load_configuration,
    load_environment,
)

# === SHARED CONFIGURATION IMPORTS ===
# SHARED_CONFIG_IMPORT: Development-only imports replaced in deployment


# ‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ IMPORT_BLOCK_END ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ

# ‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ FUNCTION_BLOCK_START ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ

# === LOGGING CONFIGURATION ===


def _initialize_logging() -> logging.Logger:
    """üîß LOGGING INITIALIZER: Setup Smart Logging System"""
    logger = create_lambda_logger("StreamlinedOAuthGateway")
    initial_debug = bool(os.environ.get("DEBUG"))
    logger.setLevel(logging.DEBUG if initial_debug else logging.INFO)
    return logger


_logger = _initialize_logging()

# Global security components (HIGH security level for OAuth)
_rate_limiter = RateLimiter()

# === SIMPLIFIED CONFIGURATION CLASSES ===


@dataclass
class OAuthConfiguration:
    """
    OAuth configuration for Alexa Smart Home account linking.

    Handles both standard OAuth and optional CloudFlare Access protection.
    Based on Alexa skill configuration:
    - Auth Code Grant flow
    - Client ID: https://pitangui.amazon.com/ (Amazon's identifier)
    - Credentials in request body authentication scheme
    """

    base_url: str
    # OAuth credentials for Home Assistant authentication
    oauth_client_id: str | None = None
    oauth_client_secret: str | None = None
    # CloudFlare Access credentials (optional enhanced security)
    cf_client_id: str | None = None
    cf_client_secret: str | None = None
    verify_ssl: bool = True

    @classmethod
    def from_environment(cls) -> "OAuthConfiguration":
        """Load OAuth configuration using same pattern as smart_home_bridge.py.

        This mimics the working configuration loading from smart_home_bridge.py
        which successfully loads CloudFlare credentials.

        Returns:
            Configured OAuthConfiguration instance.
        """
        env_vars = load_environment()
        _logger.info("Loading OAuth configuration using smart_home_bridge pattern")

        # Use same pattern as smart_home_bridge.py for configuration loading
        app_config: dict[str, Any] = {}

        # Load configuration using the working pattern
        app_config_path = env_vars.get("APP_CONFIG_PATH", "/ha-alexa/")
        _logger.debug(
            "Loading configuration from path: %s", app_config_path or "default"
        )

        try:
            config = load_configuration(
                app_config_path=app_config_path,
                return_format="configparser",
            )
            if isinstance(config, configparser.ConfigParser) and config.has_section(
                "appConfig"
            ):
                app_config = dict(config["appConfig"])
                _logger.info("‚úÖ Configuration loaded from SSM/cache")
            else:
                _logger.warning("No appConfig section found in configuration")
        except (ValueError, KeyError, TypeError) as e:
            _logger.warning("Failed to load configuration from SSM: %s", str(e))

        # Apply environment variable overrides (same as smart_home_bridge.py)
        if env_vars.get("BASE_URL") or env_vars.get("HA_BASE_URL"):
            app_config["HA_BASE_URL"] = env_vars.get("BASE_URL") or env_vars.get(
                "HA_BASE_URL"
            )
        if env_vars.get("CF_CLIENT_ID"):
            app_config["CF_CLIENT_ID"] = env_vars.get("CF_CLIENT_ID")
        if env_vars.get("CF_CLIENT_SECRET"):
            app_config["CF_CLIENT_SECRET"] = env_vars.get("CF_CLIENT_SECRET")

        # Extract configuration values (same pattern as smart_home_bridge.py)
        base_url = app_config.get("HA_BASE_URL")
        if not base_url:
            raise ValueError("Base URL not configured in appConfig")

        # Extract CloudFlare credentials (same as smart_home_bridge.py)
        cf_client_id = app_config.get("cf_client_id") or app_config.get("CF_CLIENT_ID")
        cf_client_secret = app_config.get("cf_client_secret") or app_config.get(
            "CF_CLIENT_SECRET"
        )

        # DEBUG: Log actual CloudFlare credential values
        _logger.info(
            "üîç DEBUG CF CREDENTIALS: cf_client_id=%s, cf_client_secret=%s",
            f"{cf_client_id[:10]}***" if cf_client_id else "None",
            f"{cf_client_secret[:10]}***" if cf_client_secret else "None",
        )

        verify_ssl = not bool(env_vars.get("NOT_VERIFY_SSL"))

        _logger.info(
            "OAuth configuration loaded: base_url=%s, has_cf_credentials=%s",
            base_url,
            bool(cf_client_id and cf_client_secret),
        )

        return cls(
            base_url=base_url.strip("/"),
            oauth_client_id=None,  # Not needed for OAuth gateway
            oauth_client_secret=None,  # Not needed for OAuth gateway
            cf_client_id=cf_client_id,
            cf_client_secret=cf_client_secret,
            verify_ssl=verify_ssl,
        )


# === OAUTH CACHING FUNCTIONS ===


# Module-level cache for DynamoDB client
_oauth_cache_client: Any = None


def _get_oauth_cache_client() -> Any:
    """Get DynamoDB client with lazy initialization."""
    global _oauth_cache_client  # pyright: ignore[reportUnknownMemberType]
    if _oauth_cache_client is None:
        _oauth_cache_client = boto3.resource("dynamodb")  # pyright: ignore
    return _oauth_cache_client  # pyright: ignore[reportUnknownVariableType]


def _generate_oauth_cache_key(req_dict: dict[bytes, list[bytes]]) -> str | None:
    """Generate cache key for OAuth request."""
    try:
        # Extract key parameters for cache key generation
        grant_type = req_dict.get(b"grant_type", [b""])[0].decode("utf-8")
        code = req_dict.get(b"code", [b""])[0].decode("utf-8")

        if grant_type == "authorization_code" and code:
            # Cache by authorization code for token exchange
            return f"oauth_token_{hash(code)}"
        if grant_type == "refresh_token":
            refresh_token = req_dict.get(b"refresh_token", [b""])[0].decode("utf-8")
            if refresh_token:
                return f"oauth_refresh_{hash(refresh_token)}"

        return None
    except (UnicodeDecodeError, KeyError, IndexError):
        return None


def _get_cached_oauth_token(cache_key: str) -> dict[str, Any] | None:
    """
    Retrieve cached OAuth token with dual-layer caching.

    Uses both container-level cache (fastest) and DynamoDB (persistent).
    This allows oauth_gateway.py to benefit from shared caching infrastructure
    while maintaining OAuth-specific token caching for normal requests.
    """
    # First, try container-level cache (shared infrastructure)
    try:
        container_cached = get_container_cached_config("oauth", f"token:{cache_key}")
        if container_cached:
            token_data = container_cached.get("token_data")
            if isinstance(token_data, dict):
                _logger.debug("OAuth token served from container cache")
                return cast(dict[str, Any], token_data)
    except (ValueError, KeyError, TypeError) as e:
        _logger.debug("Container cache lookup failed: %s", str(e))

    # Fallback to DynamoDB cache
    try:
        table = _get_oauth_cache_client().Table(OAUTH_TOKEN_CACHE_TABLE)
        response = table.get_item(Key={"cache_key": cache_key})

        if "Item" in response:
            item = response["Item"]
            # Check if token is still valid (5 minute cache)
            timestamp = item.get("timestamp", 0)
            # Convert Decimal to float for time comparison
            if isinstance(timestamp, Decimal):
                timestamp = float(timestamp)
            if time.time() - timestamp < 300:
                token_data = item.get("token_data")
                if isinstance(token_data, dict):
                    # Also cache in container for next request
                    cache_config_in_container(
                        "oauth", f"token:{cache_key}", {"token_data": token_data}
                    )
                    _logger.debug("OAuth token served from DynamoDB cache")
                    return cast(dict[str, Any], token_data)

    except (ClientError, BotoCoreError) as e:
        _logger.warning("OAuth DynamoDB cache read failed: %s", str(e))

    return None


def _cache_oauth_token(cache_key: str, token_data: dict[str, Any]) -> None:
    """
    Cache OAuth token with dual-layer caching.

    Stores in both container cache (for immediate reuse) and DynamoDB
    (for persistence). This enhancement allows the oauth_gateway to benefit
    from shared caching infrastructure.
    """
    # Cache in container-level cache first (shared infrastructure)
    try:
        cache_config_in_container(
            "oauth", f"token:{cache_key}", {"token_data": token_data}
        )
        _logger.debug("OAuth token cached in container")
    except (ValueError, KeyError, TypeError) as e:
        _logger.warning("Container cache write failed: %s", str(e))

    # Also cache in DynamoDB for persistence
    try:
        table = _get_oauth_cache_client().Table(OAUTH_TOKEN_CACHE_TABLE)
        table.put_item(
            Item={
                "cache_key": cache_key,
                "token_data": token_data,
                "timestamp": Decimal(str(time.time())),
                "ttl": int(time.time()) + 300,  # 5 minute TTL
            }
        )
        _logger.debug("OAuth token cached in DynamoDB")
    except (ClientError, BotoCoreError) as e:
        _logger.warning("OAuth DynamoDB cache write failed: %s", str(e))


# === MAIN LAMBDA HANDLER ===


def lambda_handler(event: dict[str, Any], context: Any) -> dict[str, Any]:
    """
    üö™ AWS LAMBDA ENTRY POINT: OAuth Authentication Gateway

    Handles OAuth authentication requests with CloudFlare protection support.
    This Lambda function is specialized for OAuth token exchange only.
    Smart Home directives should be processed by smart_home_bridge.py
    """
    # Initialize request context
    correlation_id = extract_correlation_id(context)
    _logger.info("=== OAUTH LAMBDA START (correlation: %s) ===", correlation_id)

    # üõ°Ô∏è SECURITY VALIDATION using shared infrastructure
    client_ip = event.get("headers", {}).get("X-Forwarded-For", "alexa-service")
    client_ip = client_ip.split(",")[0] if client_ip else "alexa-service"

    # Rate limiting for OAuth requests (HIGH security level)
    is_allowed, rate_limit_reason = _rate_limiter.is_allowed(client_ip)
    if not is_allowed:
        SecurityEventLogger.log_rate_limit_violation(client_ip, rate_limit_reason)
        _logger.warning("Rate limit exceeded: %s", rate_limit_reason)
        return create_error_response(
            "rate_limited", "Too many requests", 429, correlation_id
        )

    # Basic request validation
    if not event:
        SecurityEventLogger.log_validation_failure(
            client_ip, "empty_event", "Empty event received"
        )
        return create_error_response(
            "invalid_request", "Empty request", 400, correlation_id
        )

    # Log security event
    SecurityEventLogger.log_security_event(
        "oauth_gateway_start",
        client_ip,
        f"OAuth gateway processing starting (correlation: {correlation_id})",
        "INFO",
    )

    try:
        # Validate that this is an OAuth request
        request_type = _detect_request_type(event)
        _logger.info("Request type detected: %s", request_type)

        if request_type == "oauth":
            return _handle_oauth_flow(event, client_ip, correlation_id)

        # This Lambda only handles OAuth requests
        SecurityEventLogger.log_validation_failure(
            client_ip,
            "wrong_lambda",
            "Non-OAuth request sent to OAuth gateway",
        )
        return create_error_response(
            "invalid_request",
            "This endpoint only handles OAuth authentication. "
            "Smart Home requests should be sent to smart_home_bridge.",
            400,
            correlation_id,
        )

    except (OSError, RuntimeError, ValueError) as e:
        SecurityEventLogger.log_security_event(
            "oauth_gateway_error",
            client_ip,
            f"Unexpected error: {str(e)}",
            "ERROR",
        )
        _logger.error("Unexpected error in lambda_handler: %s", str(e))
        return create_error_response(
            "internal_error", "Internal server error", 500, correlation_id
        )
    finally:
        _logger.info("=== OAUTH LAMBDA END (correlation: %s) ===", correlation_id)


# === REQUEST TYPE DETECTION ===


def _detect_request_type(event: dict[str, Any]) -> str:
    """
    Detect whether this is an OAuth request.

    This OAuth Gateway only handles OAuth token exchange requests.
    Smart Home directives should be processed by smart_home_bridge.py
    """
    # Check HTTP method and content type for OAuth requests
    http_method = event.get("httpMethod") or event.get("requestContext", {}).get(
        "http", {}
    ).get("method")
    content_type = event.get("headers", {}).get("content-type", "").lower()

    # OAuth requests are typically POST with form data
    if http_method == "POST" and "application/x-www-form-urlencoded" in content_type:
        return "oauth"

    # Default to OAuth for compatibility (this Lambda only handles OAuth)
    return "oauth"


# === OAUTH AUTHENTICATION FLOW ===


def _handle_oauth_flow(
    event: dict[str, Any], client_ip: str, correlation_id: str
) -> dict[str, Any]:
    """Handle OAuth authentication flow with shared security validation."""
    SecurityEventLogger.log_security_event(
        "oauth_flow_start",
        client_ip,
        f"OAuth authentication flow starting (correlation: {correlation_id})",
        "INFO",
    )

    try:
        # Load OAuth configuration
        oauth_config = OAuthConfiguration.from_environment()

        # Validate and parse request body
        body = event.get("body", "")

        # Handle Base64 encoding (critical fix from original working code!)
        if event.get("isBase64Encoded"):
            body = base64.b64decode(body)

        # COMPREHENSIVE DEBUG LOGGING for diagnosis
        _logger.info(
            "üîç DEBUG: Raw request body (correlation: %s): type=%s, length=%d, base64=%s",
            correlation_id,
            type(body).__name__,
            len(body) if body else 0,
            event.get("isBase64Encoded", False),
        )
        _logger.info(
            "üîç DEBUG: Raw body content (correlation: %s): %s",
            correlation_id,
            repr(body)[:500] if body else "EMPTY_BODY",
        )
        _logger.info(
            "üîç DEBUG: Event headers (correlation: %s): %s",
            correlation_id,
            event.get("headers", {}),
        )
        _logger.info(
            "üîç DEBUG: Event HTTP method (correlation: %s): %s",
            correlation_id,
            event.get("httpMethod")
            or event.get("requestContext", {}).get("http", {}).get("method"),
        )

        if isinstance(body, str):
            req_dict = urllib.parse.parse_qs(body.encode("utf-8"))
        else:
            req_dict = urllib.parse.parse_qs(body)

        # Log parsed request details for debugging
        _logger.info(
            "üîç DEBUG: Parsed OAuth data (correlation: %s): parsed_keys=%s",
            correlation_id,
            [key.decode("utf-8") for key in req_dict] if req_dict else [],
        )

        # Log each parsed parameter value
        for key, values in req_dict.items():
            if values:
                key_str = key.decode("utf-8")
                value_str = values[0].decode("utf-8")
                # Mask sensitive values for security
                if key_str.lower() in ["client_secret", "code"]:
                    value_display = (
                        f"{value_str[:4]}***{value_str[-4:]}"
                        if len(value_str) > 8
                        else "***"
                    )
                else:
                    value_display = value_str
                _logger.info(
                    "üîç DEBUG: OAuth param (correlation: %s): %s=%s",
                    correlation_id,
                    key_str,
                    value_display,
                )

        # Validate required OAuth parameters
        grant_type = (
            req_dict.get(b"grant_type", [b""])[0].decode("utf-8")
            if req_dict.get(b"grant_type")
            else ""
        )
        if not grant_type:
            _logger.error(
                "Missing grant_type in OAuth request (correlation: %s)", correlation_id
            )
            return create_error_response(
                "invalid_request", "Missing grant_type parameter", 400, correlation_id
            )

        if grant_type == "authorization_code":
            code = (
                req_dict.get(b"code", [b""])[0].decode("utf-8")
                if req_dict.get(b"code")
                else ""
            )
            if not code:
                _logger.error(
                    "Missing authorization code in OAuth request (correlation: %s)",
                    correlation_id,
                )
                return create_error_response(
                    "invalid_request",
                    "Missing code parameter for authorization_code grant",
                    400,
                    correlation_id,
                )

        # Security validation using shared infrastructure
        body_str = body if isinstance(body, str) else body.decode("utf-8")
        is_valid_size, size_reason = SecurityValidator.validate_request_size(
            len(body_str)
        )
        if not is_valid_size:
            SecurityEventLogger.log_validation_failure(
                client_ip, "request_size", size_reason
            )
            return create_error_response(
                "invalid_request", "Request too large", 400, correlation_id
            )

        # Check cache first for performance
        cache_key = _generate_oauth_cache_key(req_dict)
        if cache_key:
            cached_response = _get_cached_oauth_token(cache_key)
            if cached_response:
                SecurityEventLogger.log_security_event(
                    "oauth_cache_hit",
                    client_ip,
                    f"OAuth token served from cache (correlation: {correlation_id})",
                    "INFO",
                )
                return cached_response

        # Perform OAuth token exchange
        response = _perform_oauth_exchange(
            oauth_config, req_dict, client_ip, correlation_id
        )

        # Cache successful response
        if cache_key and response.get("statusCode") == 200:
            _cache_oauth_token(cache_key, response)

        SecurityEventLogger.log_oauth_success(client_ip, "home_assistant")
        return response

    except ValueError as e:
        SecurityEventLogger.log_validation_failure(client_ip, "oauth_config", str(e))
        return create_error_response("invalid_request", str(e), 400, correlation_id)
    except (OSError, RuntimeError) as e:
        SecurityEventLogger.log_security_event(
            "oauth_error",
            client_ip,
            f"OAuth flow error: {str(e)} (correlation: {correlation_id})",
            "ERROR",
        )
        return create_error_response(
            "internal_error", "OAuth processing failed", 500, correlation_id
        )


def _perform_oauth_exchange(
    config: OAuthConfiguration,
    req_dict: dict[bytes, list[bytes]],
    client_ip: str,
    correlation_id: str,
) -> dict[str, Any]:
    """Perform the actual OAuth token exchange with Home Assistant."""

    # QUICK FIX: For personal use, bypass HA OAuth and return HA token directly
    # This avoids the complexity of configuring Home Assistant OAuth2 for Alexa

    # Extract grant type for validation
    grant_type = (
        req_dict.get(b"grant_type", [b""])[0].decode("utf-8")
        if req_dict.get(b"grant_type")
        else ""
    )

    if grant_type == "authorization_code":
        # Get the authorization code from the request
        auth_code = (
            req_dict.get(b"code", [b""])[0].decode("utf-8")
            if req_dict.get(b"code")
            else ""
        )

        _logger.info(
            "üîß BYPASS: OAuth bypass mode - returning HA token directly (correlation: %s): "
            "grant_type=%s, code_length=%d",
            correlation_id,
            grant_type,
            len(auth_code) if auth_code else 0,
        )

        # Load the actual HA token from environment/SSM
        try:
            # Use already imported shared configuration loading to get HA_TOKEN
            app_config = load_configuration("/ha-alexa/")
            ha_token = (
                app_config.get("HA_TOKEN") if isinstance(app_config, dict) else None
            )

            if not ha_token or not isinstance(ha_token, str):
                _logger.error(
                    "üö® BYPASS ERROR: No HA_TOKEN found in configuration (correlation: %s)",
                    correlation_id,
                )
                return create_error_response(
                    "server_error", "Configuration error", 500, correlation_id
                )

            # Return OAuth2 compliant response with your HA token
            oauth_response = {
                "access_token": ha_token,
                "token_type": "Bearer",
                "expires_in": 3600,  # 1 hour
                "scope": "read write",
            }

            _logger.info(
                "‚úÖ BYPASS SUCCESS: Returning HA token as OAuth response (correlation: %s): "
                "token_length=%d",
                correlation_id,
                len(ha_token),
            )

            import json

            return {
                "statusCode": 200,
                "headers": {"Content-Type": "application/json"},
                "body": json.dumps(oauth_response),
            }

        except Exception as e:
            _logger.error(
                "üö® BYPASS ERROR: Failed to load HA_TOKEN (correlation: %s): %s",
                correlation_id,
                str(e),
            )
            return create_error_response(
                "server_error", f"Token loading failed: {str(e)}", 500, correlation_id
            )

    # For other grant types, return error
    _logger.error(
        "üö® UNSUPPORTED: Only authorization_code grant supported in bypass mode (correlation: %s): "
        "grant_type=%s",
        correlation_id,
        grant_type,
    )
    return create_error_response(
        "unsupported_grant_type",
        f"Grant type '{grant_type}' not supported",
        400,
        correlation_id,
    )


# ‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ FUNCTION_BLOCK_END ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ

# === UTILITY FUNCTIONS ===
# (All utility functions moved to shared_configuration.py for reuse)
